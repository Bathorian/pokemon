<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pokémon Lookup (Vue)</title>
  <style>
    /* Dark theme styles */
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 20px; background: #0b1220; color: #e5e7eb; }
    .container { max-width: 900px; margin: 0 auto; }
    h1 { font-size: 1.6rem; margin-bottom: 1rem; }
    .search { display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap; }
    input[type="text"], select { flex: 1; min-width: 220px; padding: 10px 12px; font-size: 1rem; border: 1px solid #374151; border-radius: 8px; background: #111827; color: #e5e7eb; }
    button { padding: 10px 14px; border: 0; background: #2563eb; color: white; border-radius: 8px; cursor: pointer; font-weight: 600; }
    button:disabled { background: #334155; cursor: not-allowed; }
    .card { background: #111827; border: 1px solid #1f2937; border-radius: 12px; padding: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.35); }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
    .media { width: 160px; text-align: center; }
    .media img { width: 120px; height: 120px; image-rendering: pixelated; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #1e293b; color: #e5e7eb; font-size: 0.85rem; margin-right: 6px; border: 1px solid rgba(255,255,255,0.08); }
    .muted { color: #94a3b8; font-size: 0.95rem; }
    .error { background: #3f1d1d; color: #fecaca; border: 1px solid #7f1d1d; padding: 10px 12px; border-radius: 8px; }
    .section-title { font-weight: 700; margin-top: 12px; margin-bottom: 6px; }
    a { color: #60a5fa; text-decoration: none; }
    /* Custom dropdown for Pokémon with inline sprites */
    .dropdown { position: relative; flex: 1; min-width: 260px; }
    .dropdown-toggle { width: 100%; text-align: left; padding: 10px 12px; font-size: 1rem; border: 1px solid #374151; border-radius: 8px; background: #111827; color: #e5e7eb; display: flex; align-items: center; gap: 8px; }
    .dropdown-toggle img { width: 28px; height: 28px; image-rendering: pixelated; }
    .dropdown-menu { position: absolute; z-index: 10; background: #0f172a; border: 1px solid #1f2937; border-radius: 8px; width: 100%; max-height: 300px; overflow: auto; margin-top: 6px; box-shadow: 0 10px 24px rgba(0,0,0,0.45); }
    .dropdown-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; cursor: pointer; color: #e5e7eb; }
    .dropdown-item img { width: 28px; height: 28px; image-rendering: pixelated; }
    .dropdown-item:hover { background: #1f2937; }
  </style>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- Chart.js for visualizing base stats -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <div id="app" class="container">
    <h1>Pokémon Lookup</h1>
    <div class="search">
      <select v-model="selectedGen" @change="loadSpecies" :disabled="loading || generations.length === 0" aria-label="Generation selector">
        <option value="" disabled>Select generation…</option>
        <option v-for="g in generations" :key="g.id" :value="g.id">Generation {{ g.id }} — {{ g.name }}</option>
      </select>

      <!-- Custom Pokémon dropdown with sprite icons -->
      <div class="dropdown" :aria-disabled="loading || species.length === 0">
        <button type="button" class="dropdown-toggle" @click="toggleSpeciesList" :disabled="loading || species.length === 0" aria-haspopup="listbox" :aria-expanded="speciesOpen">
          <template v-if="selectedPokemon">
            <img :src="selectedPokemon.sprite" :alt="selectedPokemon.name + ' sprite'" />
            <span style="text-transform: capitalize;">{{ selectedPokemon.name }}</span>
          </template>
          <template v-else>
            <span class="muted">Select a Pokémon…</span>
          </template>
        </button>
        <div v-if="speciesOpen" class="dropdown-menu" role="listbox">
          <div class="dropdown-item" v-for="item in species" :key="item.id + '-' + item.name" role="option" @click="chooseSpecies(item)">
            <img :src="item.sprite" :alt="item.name + ' sprite'" />
            <span style="text-transform: capitalize;">{{ item.name }}</span>
          </div>
        </div>
      </div>

      <button @click="search" :disabled="loading || !selectedPokemon">{{ loading ? 'Loading…' : 'Load' }}</button>
    </div>

    <div v-if="error" class="error" role="alert">{{ error }}</div>

    <div v-if="pokemon" class="card">
      <div class="row">
        <div class="media" v-if="primarySprite">
          <img :src="primarySprite" :alt="`Sprite of ${pokemon.name}`" />
          <div class="muted">Sprite</div>
        </div>
        <div style="flex:1; min-width: 240px;">
          <div class="section-title" style="margin-top:0;">Summary</div>
          <div class="grid">
            <div><strong>Name:</strong> {{ pokemon.name }}</div>
            <div><strong>ID:</strong> {{ pokemon.id }}</div>
            <div><strong>Height:</strong> {{ pokemon.height }}</div>
            <div><strong>Weight:</strong> {{ pokemon.weight }}</div>
            <div v-if="pokemon.base_experience != null"><strong>Base XP:</strong> {{ pokemon.base_experience }}</div>
            <div v-if="pokemon.order != null"><strong>Order:</strong> {{ pokemon.order }}</div>
            <div v-if="pokemon.is_default != null"><strong>Is default:</strong> {{ pokemon.is_default }}</div>
          </div>

          <div class="section-title">Types</div>
          <div v-if="types.length">
            <span v-for="t in types" :key="t.slot" class="pill" :style="typeStyle(t.name)">[{{ t.slot }}] {{ t.name }}</span>
          </div>
          <div v-else class="muted">n/a</div>

          <div class="section-title">Abilities</div>
          <div v-if="abilities.length">
            <div v-for="a in abilities" :key="a.key">{{ a.name }} <span class="muted">(hidden={{ a.hidden }}, slot={{ a.slot }})</span></div>
          </div>
          <div v-else class="muted">n/a</div>

          <div class="section-title">Base stats</div>
          <div class="grid">
            <div v-for="s in stats" :key="s.name"><strong>{{ s.name }}:</strong> {{ s.value }}</div>
          </div>
          <div style="margin-top:8px;">
            <canvas ref="statsCanvas" aria-label="Base stats chart" role="img" style="max-width: 520px; background:#0b1220; border:1px solid #1f2937; border-radius:8px; padding:8px;"></canvas>
          </div>

          <div class="section-title" v-if="pokemon.held_items && pokemon.held_items.length">Held items</div>
          <div v-if="pokemon.held_items && pokemon.held_items.length" class="grid">
            <div v-for="hi in pokemon.held_items" :key="hi.item.name">{{ hi.item.name }}</div>
          </div>

          <div class="section-title" v-if="pokemon.forms && pokemon.forms.length">Forms</div>
          <div v-if="pokemon.forms && pokemon.forms.length" class="grid">
            <div v-for="f in pokemon.forms" :key="f.name">{{ f.name }}</div>
          </div>

          <div class="section-title" v-if="pokemon.species">Species</div>
          <div v-if="pokemon.species" class="muted">
            <span v-if="pokemon.species.name">{{ pokemon.species.name }}</span>
            <span v-if="pokemon.species.url"> — <a :href="pokemon.species.url" target="_blank" rel="noreferrer noopener">API</a></span>
          </div>

          <div class="section-title" v-if="pokemon.location_area_encounters">Encounters</div>
          <div v-if="pokemon.location_area_encounters">
            <div v-if="encountersLoading" class="muted">Loading encounter locations…</div>
            <div v-else-if="encountersError" class="error" role="alert">{{ encountersError }}</div>
            <template v-else>
              <div v-if="encounters && encounters.locations && encounters.locations.length">
                <div class="muted" style="margin-bottom:6px;">Found {{ encounters.total_locations }} location<span v-if="encounters.total_locations !== 1">s</span>.</div>
                <div class="grid" style="grid-template-columns: 1fr; gap: 10px;">
                  <div v-for="loc in encounters.locations" :key="loc.location" class="card" style="padding:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
                      <div style="font-weight:700; text-transform: capitalize;">{{ prettify(loc.location) }}</div>
                      <a class="muted" :href="`https://pokeapi.co/api/v2/location-area/${loc.location}`" target="_blank" rel="noreferrer noopener">Open API</a>
                    </div>
                    <div v-if="loc.versions && loc.versions.length" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
                      <div v-for="v in loc.versions" :key="v.version" class="pill" title="Max chance">
                        {{ v.version }} — {{ v.max_chance }}%
                      </div>
                    </div>
                    <div v-if="loc.versions && loc.versions.length" class="muted" style="margin-top:6px;">
                      <template v-for="v in loc.versions" :key="v.version + '-methods'">
                        <div style="margin-top:4px;">
                          <strong style="text-transform: capitalize;">{{ v.version }} methods:</strong>
                          <span v-for="m in (v.methods || [])" :key="v.version + m" class="pill" style="margin-left:6px; text-transform: capitalize;">{{ m }}</span>
                        </div>
                      </template>
                    </div>
                  </div>
                </div>
              </div>
              <div style="margin-top:6px;">
                <a class="muted" :href="encounters && encounters.full_url ? encounters.full_url : pokemon.location_area_encounters" target="_blank" rel="noreferrer noopener">Open full encounters JSON</a>
              </div>
            </template>
          </div>

          <div class="section-title" v-if="cries.latest || cries.legacy">Cries</div>
          <div v-if="cries.latest || cries.legacy" class="grid">
            <div v-if="cries.latest">
              <div class="muted">Latest</div>
              <audio :src="cries.latest" controls preload="none"></audio>
            </div>
            <div v-if="cries.legacy">
              <div class="muted">Legacy</div>
              <audio :src="cries.legacy" controls preload="none"></audio>
            </div>
          </div>

          <div class="section-title" v-if="spriteVariants.length">Sprites gallery</div>
          <div v-if="spriteVariants.length" class="grid">
            <div v-for="sp in spriteVariants" :key="sp.key" style="text-align:center;">
              <img :src="sp.url" :alt="sp.label" style="width:96px;height:96px;image-rendering:pixelated;"/>
              <div class="muted" style="margin-top:4px;">{{ sp.label }}</div>
            </div>
          </div>

          <!-- Species details (from pokemon-species) -->
          <div class="section-title" v-if="speciesDetails">Species details</div>
          <div v-if="speciesDetails" class="grid">
            <div v-if="englishGenus(speciesDetails.genera)"><strong>Category:</strong> {{ englishGenus(speciesDetails.genera) }}</div>
            <div v-if="speciesDetails.generation"><strong>Generation:</strong> {{ prettify(speciesDetails.generation.name || speciesDetails.generation) }}</div>
            <div v-if="speciesDetails.color"><strong>Color:</strong> {{ prettify(speciesDetails.color.name || speciesDetails.color) }}</div>
            <div v-if="speciesDetails.shape"><strong>Shape:</strong> {{ prettify(speciesDetails.shape.name || speciesDetails.shape) }}</div>
            <div v-if="speciesDetails.habitat"><strong>Habitat:</strong> {{ prettify(speciesDetails.habitat.name || speciesDetails.habitat) }}</div>
            <div v-if="speciesDetails.growth_rate"><strong>Growth rate:</strong> {{ prettify(speciesDetails.growth_rate.name || speciesDetails.growth_rate) }}</div>
            <div v-if="speciesDetails.egg_groups && speciesDetails.egg_groups.length"><strong>Egg groups:</strong> {{ speciesDetails.egg_groups.map(e => prettify(e.name || e)).join(', ') }}</div>
            <div v-if="speciesDetails.capture_rate != null"><strong>Capture rate:</strong> {{ speciesDetails.capture_rate }} <span class="muted">(~{{ captureRateApprox(speciesDetails.capture_rate) }}% with a Poké Ball at full HP)</span></div>
            <div v-if="speciesDetails.base_happiness != null"><strong>Base happiness:</strong> {{ speciesDetails.base_happiness }}</div>
            <div v-if="speciesDetails.gender_rate != null"><strong>Gender rate:</strong> {{ speciesDetails.gender_rate }}</div>
            <div v-if="speciesDetails.hatch_counter != null"><strong>Hatch counter:</strong> {{ speciesDetails.hatch_counter }}</div>
            <div v-if="speciesDetails.has_gender_differences != null"><strong>Gender differences:</strong> {{ speciesDetails.has_gender_differences }}</div>
            <div v-if="speciesDetails.forms_switchable != null"><strong>Forms switchable:</strong> {{ speciesDetails.forms_switchable }}</div>
            <div v-if="speciesDetails.is_baby != null"><strong>Baby:</strong> {{ speciesDetails.is_baby }}</div>
            <div v-if="speciesDetails.is_legendary != null"><strong>Legendary:</strong> {{ speciesDetails.is_legendary }}</div>
            <div v-if="speciesDetails.is_mythical != null"><strong>Mythical:</strong> {{ speciesDetails.is_mythical }}</div>
            <div v-if="speciesDetails.evolves_from_species"><strong>Evolves from:</strong> {{ prettify(speciesDetails.evolves_from_species.name || speciesDetails.evolves_from_species) }}</div>
          </div>

          <div v-if="speciesDetails && speciesDetails.flavor_text" style="margin-top:8px;">
            <div class="section-title">Flavor text</div>
            <div class="muted" style="white-space: pre-line;">{{ speciesDetails.flavor_text }}</div>
          </div>

          <div v-if="speciesDetails && speciesDetails.evolution_chain && speciesDetails.evolution_chain.url" style="margin-top:8px;">
            <div class="section-title">Evolution chain</div>
            <!-- Visual graph -->
            <div v-if="evoLoading" class="muted">Loading evolution chain…</div>
            <div v-else-if="evoError" class="error" role="alert">{{ evoError }}</div>
            <div v-else-if="evoPaths.length" class="grid" style="grid-template-columns: 1fr; gap: 10px;">
              <!-- Render each path (branch) as a row -->
              <div v-for="(p, idx) in evoPaths" :key="idx" class="card" style="padding:10px;">
                <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                  <template v-for="(step, i) in p.steps" :key="step.key">
                    <div style="display:flex; align-items:center; gap:8px;">
                      <div style="text-align:center; min-width:110px;">
                        <img :src="step.sprite" :alt="step.name + ' sprite'" style="width:72px; height:72px; image-rendering: pixelated; display:block; margin:0 auto;" />
                        <div style="text-transform: capitalize; font-weight:600;">{{ step.name }}</div>
                      </div>
                      <template v-if="i < p.steps.length - 1">
                        <div style="display:flex; align-items:center; gap:8px;">
                          <span class="pill" v-for="cond in p.links[i].conditions" :key="cond">{{ cond }}</span>
                          <span class="muted" aria-hidden="true" style="font-size:1.2rem;">→</span>
                        </div>
                      </template>
                    </div>
                  </template>
                </div>
              </div>
            </div>
            <!-- Fallback link -->
            <div style="margin-top:6px;">
              <a class="muted" :href="speciesDetails.evolution_chain.url" target="_blank" rel="noreferrer noopener">Open evolution chain API</a>
            </div>
          </div>

          <div v-if="speciesDetails && speciesDetails.varieties && speciesDetails.varieties.length" style="margin-top:8px;">
            <div class="section-title">Varieties</div>
            <div>
              <span v-for="v in speciesDetails.varieties" :key="(v.pokemon?.name || v.name)" class="pill" style="text-transform: capitalize;">
                {{ (v.pokemon?.name || v.name) }}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <p class="muted" style="margin-top:16px;">Data from <a href="https://pokeapi.co/" target="_blank" rel="noreferrer noopener">PokeAPI</a>. This is a static page using Vue 3 from CDN.</p>
  </div>

  <script>
    const { createApp, ref, computed, onMounted, watch, nextTick } = Vue;
    createApp({
      setup() {
        // selectors state
        const generations = ref([]); // [{id, name, url}]
        const selectedGen = ref("");
        const species = ref([]); // [{id, name, sprite}]
        const selectedPokemon = ref(null); // {id, name, sprite}
        const speciesOpen = ref(false);

        const loading = ref(false);
        const error = ref("");
        const pokemon = ref(null);
        const speciesDetails = ref(null);
        // Evolution chain state
        const evoLoading = ref(false);
        const evoError = ref("");
        // Each path: { steps: [{ key, name, id, sprite }], links: [{ conditions: ["..."] }] }
        const evoPaths = ref([]);
        // Encounters
        const encountersLoading = ref(false);
        const encountersError = ref("");
        const encounters = ref(null);

        // Prefer local backend to reduce frontend logic; fall back to PokeAPI if backend is unavailable
        const API_BASE = "/api/pokemon/"; // backend proxy; fallback handled per-request
        const GENERATION_LIST = "/api/generation";
        const GENERATION_DETAIL = (id) => `/api/generation/${id}/species`;
        const SPRITE_BASE = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon"; // used only for fallback cases

        const primarySprite = computed(() => pokemon.value?.sprites?.front_default || "");
        const types = computed(() => (pokemon.value?.types || []).map(t => ({ slot: t.slot, name: t.type?.name })));
        const abilities = computed(() => (pokemon.value?.abilities || []).map(a => ({
          key: `${a.ability?.name}-${a.slot}-${a.is_hidden}`,
          name: a.ability?.name,
          hidden: a.is_hidden,
          slot: a.slot
        })));
        const stats = computed(() => (pokemon.value?.stats || []).map(s => ({
          name: s.stat?.name,
          value: s.base_stat
        })));
        const cries = computed(() => pokemon.value?.cries || {});

        // Sprite variants gallery
        const spriteVariants = computed(() => {
          const s = pokemon.value?.sprites || {};
          if (!s) return [];
          const mapping = [
            ["front_default", "Front"],
            ["back_default", "Back"],
            ["front_shiny", "Front shiny"],
            ["back_shiny", "Back shiny"],
            ["front_female", "Front female"],
            ["back_female", "Back female"],
            ["front_shiny_female", "Front shiny female"],
            ["back_shiny_female", "Back shiny female"],
          ];
          const out = [];
          for (const [key, label] of mapping) {
            const url = s?.[key];
            if (url) out.push({ key, label, url });
          }
          return out;
        });

        // Type colors (approx. Pokemon type palette)
        const typeColors = {
          normal:   { bg: "#a8a77a", fg: "#0b1220" },
          fire:     { bg: "#ee8130", fg: "#0b1220" },
          water:    { bg: "#6390f0", fg: "#0b1220" },
          electric: { bg: "#f7d02c", fg: "#0b1220" },
          grass:    { bg: "#7ac74c", fg: "#0b1220" },
          ice:      { bg: "#96d9d6", fg: "#0b1220" },
          fighting: { bg: "#c22e28", fg: "#e5e7eb" },
          poison:   { bg: "#a33ea1", fg: "#e5e7eb" },
          ground:   { bg: "#e2bf65", fg: "#0b1220" },
          flying:   { bg: "#a98ff3", fg: "#0b1220" },
          psychic:  { bg: "#f95587", fg: "#0b1220" },
          bug:      { bg: "#a6b91a", fg: "#0b1220" },
          rock:     { bg: "#b6a136", fg: "#0b1220" },
          ghost:    { bg: "#735797", fg: "#e5e7eb" },
          dragon:   { bg: "#6f35fc", fg: "#e5e7eb" },
          dark:     { bg: "#705746", fg: "#e5e7eb" },
          steel:    { bg: "#b7b7ce", fg: "#0b1220" },
          fairy:    { bg: "#d685ad", fg: "#0b1220" },
        };

        function typeStyle(typeName) {
          const c = typeColors[(typeName || "").toLowerCase()];
          if (!c) return {};
          return { background: c.bg, color: c.fg, borderColor: "rgba(0,0,0,0.18)" };
        }

        // Chart.js for base stats
        const statsCanvas = ref(null);
        let statsChart = null;

        function buildStatsDataset() {
          const order = ["hp", "attack", "defense", "special-attack", "special-defense", "speed"];
          const dict = Object.fromEntries((pokemon.value?.stats || []).map(s => [s.stat?.name, s.base_stat]));
          return order.map(k => Number(dict[k] || 0));
        }

        async function renderStatsChart() {
          await nextTick();
          const canvas = statsCanvas.value;
          if (!canvas) return;
          const labels = ["HP", "Attack", "Defense", "Sp. Atk", "Sp. Def", "Speed"];
          const data = buildStatsDataset();
          const cfg = {
            type: 'radar',
            data: {
              labels,
              datasets: [{
                label: 'Base stats',
                data,
                borderColor: '#60a5fa',
                backgroundColor: 'rgba(96,165,250,0.2)',
                pointBackgroundColor: '#93c5fd',
                pointBorderColor: '#1f2937',
              }]
            },
            options: {
              responsive: true,
              scales: {
                r: {
                  angleLines: { color: '#1f2937' },
                  grid: { color: '#1f2937' },
                  pointLabels: { color: '#e5e7eb' },
                  ticks: { color: '#94a3b8', showLabelBackdrop: false }
                }
              },
              plugins: {
                legend: { labels: { color: '#e5e7eb' } }
              }
            }
          };
          if (statsChart) {
            statsChart.destroy();
            statsChart = null;
          }
          statsChart = new Chart(canvas, cfg);
        }

        async function loadGenerations() {
          try {
            error.value = "";
            // Try backend first
            let data = null;
            try {
              const resp = await fetch(GENERATION_LIST);
              if (resp.ok) data = await resp.json();
            } catch (_) { /* ignore */ }
            if (!data) {
              // Fallback to PokeAPI directly
              const resp = await fetch("https://pokeapi.co/api/v2/generation?limit=100");
              if (!resp.ok) throw new Error(`Failed to load generations (${resp.status})`);
              const raw = await resp.json();
              const gens = (raw.results || []).map((r) => {
                const m = (r.url || "").match(/\/(\d+)\/?$/);
                const id = m ? Number(m[1]) : r.name;
                return { id, name: r.name, url: r.url };
              }).sort((a,b) => (a.id > b.id ? 1 : -1));
              generations.value = gens;
              return;
            }
            const gens = (data.results || []).sort((a,b) => (a.id > b.id ? 1 : -1));
            generations.value = gens;
          } catch (e) {
            error.value = e?.message || String(e);
          }
        }

        async function loadSpecies() {
          species.value = [];
          selectedPokemon.value = null;
          speciesOpen.value = false;
          pokemon.value = null;
          speciesDetails.value = null;
          if (!selectedGen.value) return;
          loading.value = true;
          error.value = "";
          try {
            // Try backend enhanced list first
            let data = null;
            try {
              const resp = await fetch(GENERATION_DETAIL(selectedGen.value));
              if (resp.ok) data = await resp.json();
            } catch (_) { /* ignore */ }

            if (data && Array.isArray(data.results)) {
              species.value = data.results;
              return;
            }

            // Fallback to PokeAPI generation details and build the list client-side
            const resp2 = await fetch(`https://pokeapi.co/api/v2/generation/${selectedGen.value}`);
            if (!resp2.ok) throw new Error(`Failed to load generation ${selectedGen.value} (${resp2.status})`);
            const raw = await resp2.json();
            const list = (raw.pokemon_species || [])
              .map(s => {
                const name = s.name;
                const m = (s.url || "").match(/\/(\d+)\/?$/);
                const id = m ? Number(m[1]) : null;
                const sprite = id ? `${SPRITE_BASE}/${id}.png` : "";
                return { id: id ?? name, name, sprite };
              })
              .filter(item => !!item.name)
              .sort((a, b) => a.name.localeCompare(b.name));
            species.value = list;
          } catch (e) {
            error.value = e?.message || String(e);
          } finally {
            loading.value = false;
          }
        }

        function toggleSpeciesList() {
          if (loading.value || species.value.length === 0) return;
          speciesOpen.value = !speciesOpen.value;
        }

        function chooseSpecies(item) {
          selectedPokemon.value = item;
          speciesOpen.value = false;
        }

        async function search() {
          error.value = "";
          pokemon.value = null;
          speciesDetails.value = null;
          evoPaths.value = [];
          evoError.value = "";
          evoLoading.value = false;
          encounters.value = null;
          encountersError.value = "";
          encountersLoading.value = false;
          const q = (selectedPokemon.value?.name || "").trim().toLowerCase();
          if (!q) {
            error.value = "Please select a Pokémon.";
            return;
          }
          loading.value = true;
          try {
            // Try backend first
            let data = null;
            try {
              const resp = await fetch(API_BASE + encodeURIComponent(q));
              if (resp.ok) data = await resp.json();
            } catch (_) { /* ignore */ }
            if (!data) {
              const resp2 = await fetch("https://pokeapi.co/api/v2/pokemon/" + encodeURIComponent(q));
              if (resp2.status === 404) throw new Error(`Pokémon "${q}" not found (404).`);
              if (!resp2.ok) throw new Error(`Failed to load Pokémon (${resp2.status})`);
              data = await resp2.json();
            }
            pokemon.value = data;
            // Render chart after setting pokemon
            renderStatsChart();
            // Load species details (from backend if available, or directly from PokeAPI)
            await loadSpeciesDetails(q, data);
            // After species details, load and visualize evolution chain
            await loadEvolutionChain();
            // Load encounter locations (backend-first, then PokeAPI fallback)
            await loadEncounters(q, data);
          } catch (e) {
            error.value = e?.message || String(e);
          } finally {
            loading.value = false;
          }
        }

        function latestEnglishFlavor(entries) {
          if (!Array.isArray(entries)) return "";
          // filter english entries, take the last one to approximate latest
          const en = entries.filter(e => (e.language?.name || e.language) === 'en');
          if (!en.length) return "";
          // normalize whitespace/newlines
          const txt = (en[en.length - 1].flavor_text || "").replace(/\s+/g, ' ').replace(/\u000c/g, ' ').trim();
          return txt;
        }

        async function loadSpeciesDetails(identifier, pokeData) {
          try {
            try {
              const resp = await fetch(`/api/pokemon-species/${encodeURIComponent(identifier)}`);
              if (resp.ok) {
                const s = await resp.json();
                // Expect already summarized shape from backend
                speciesDetails.value = s;
                return;
              }
            } catch (_) {
              // ignore and fallback
            }

            // Fallback: fetch species directly from PokeAPI using the URL in pokemon data
            const url = pokeData?.species?.url;
            if (!url) return;
            const sResp = await fetch(url);
            if (!sResp.ok) return;
            const raw = await sResp.json();
            // Build a lightweight summary to match backend keys
            speciesDetails.value = {
              id: raw.id,
              name: raw.name,
              order: raw.order,
              gender_rate: raw.gender_rate,
              capture_rate: raw.capture_rate,
              base_happiness: raw.base_happiness,
              is_baby: raw.is_baby,
              is_legendary: raw.is_legendary,
              is_mythical: raw.is_mythical,
              hatch_counter: raw.hatch_counter,
              has_gender_differences: raw.has_gender_differences,
              forms_switchable: raw.forms_switchable,
              growth_rate: raw.growth_rate,
              egg_groups: raw.egg_groups,
              color: raw.color,
              shape: raw.shape,
              evolves_from_species: raw.evolves_from_species,
              evolution_chain: raw.evolution_chain,
              habitat: raw.habitat,
              generation: raw.generation,
              names: raw.names,
              genera: raw.genera,
              varieties: raw.varieties,
              flavor_text: latestEnglishFlavor(raw.flavor_text_entries || []),
            };
          } catch (_) {
            // non-fatal for page
          }
        }

        function extractIdFromUrl(url) {
          if (typeof url !== 'string') return null;
          const m = url.match(/\/(\d+)\/?$/);
          return m ? Number(m[1]) : null;
        }

        function summarizeEvolutionConditions(details) {
          if (!Array.isArray(details) || !details.length) return ["level up"]; // generic
          const chips = [];
          const d = details[0]; // often only one entry
          // Common fields
          if (d.min_level != null) chips.push(`Lv ${d.min_level}`);
          if (d.item?.name) chips.push(`item: ${d.item.name}`);
          if (d.held_item?.name) chips.push(`holds: ${d.held_item.name}`);
          if (d.trigger?.name && !/level-up/i.test(d.trigger.name)) chips.push(d.trigger.name);
          if (d.time_of_day) chips.push(d.time_of_day);
          if (d.min_happiness != null) chips.push(`happiness ≥ ${d.min_happiness}`);
          if (d.min_beauty != null) chips.push(`beauty ≥ ${d.min_beauty}`);
          if (d.min_affection != null) chips.push(`affection ≥ ${d.min_affection}`);
          if (d.known_move?.name) chips.push(`knows: ${d.known_move.name}`);
          if (d.known_move_type?.name) chips.push(`move type: ${d.known_move_type.name}`);
          if (d.location?.name) chips.push(`at: ${d.location.name}`);
          if (d.needs_overworld_rain) chips.push(`raining`);
          if (d.party_species?.name) chips.push(`party: ${d.party_species.name}`);
          if (d.party_type?.name) chips.push(`party type: ${d.party_type.name}`);
          if (d.relative_physical_stats != null) chips.push(`phys.stats: ${d.relative_physical_stats}`);
          if (d.trade_species?.name) chips.push(`trade for: ${d.trade_species.name}`);
          if (d.turn_upside_down) chips.push(`hold console upside-down`);
          if (!chips.length) chips.push(d.trigger?.name || "evolves");
          return chips;
        }


        function buildPathsFromChainNode(node, accSteps, accLinks, paths) {
          // current species
          const sp = node?.species || {};
          const name = sp.name;
          const id = extractIdFromUrl(sp.url);
          const sprite = id ? `${SPRITE_BASE}/${id}.png` : '';
          const step = { key: `${name}-${id ?? 'x'}`, name, id, sprite };
          const stepsNext = [...accSteps, step];

          const evolvesTo = Array.isArray(node?.evolves_to) ? node.evolves_to : [];
          if (evolvesTo.length === 0) {
            // end of path
            paths.push({ steps: stepsNext, links: accLinks });
            return;
          }
          for (const ev of evolvesTo) {
            const conds = summarizeEvolutionConditions(ev.evolution_details || []);
            const linksNext = [...accLinks, { conditions: conds }];
            buildPathsFromChainNode(ev, stepsNext, linksNext, paths);
          }
        }



        async function loadEvolutionChain() {
          evoPaths.value = [];
          evoError.value = "";
          const chainUrl = speciesDetails.value?.evolution_chain?.url;
          if (!chainUrl) return;
          evoLoading.value = true;
          try {
            let data = null;
            // Try backend pre-parsed paths first if we can extract an id
            const id = extractIdFromUrl(chainUrl);
            if (id) {
              try {
                const rPaths = await fetch(`/api/evolution-chain/${id}/paths`);
                if (rPaths.ok) {
                  const payload = await rPaths.json();
                  if (payload && Array.isArray(payload.paths)) {
                    evoPaths.value = payload.paths.filter(p => Array.isArray(p.steps) && p.steps.length > 0);
                    return; // done, no client-side parsing needed
                  }
                }
                // Fallback to raw chain via backend
                const r = await fetch(`/api/evolution-chain/${id}`);
                if (r.ok) data = await r.json();
              } catch (_) { /* ignore */ }
            }
            if (!data) {
              const r2 = await fetch(chainUrl);
              if (!r2.ok) throw new Error(`Failed to load evolution chain (${r2.status})`);
              data = await r2.json();
            }
            const root = data?.chain;
            if (!root) throw new Error("No evolution chain data.");
            const paths = [];
            buildPathsFromChainNode(root, [], [], paths);
            // Filter out degenerate paths
            evoPaths.value = paths.filter(p => Array.isArray(p.steps) && p.steps.length > 0);
          } catch (e) {
            evoError.value = e?.message || String(e);
          } finally {
            evoLoading.value = false;
          }
        }

        function prettify(name) {
          if (typeof name !== 'string') return name;
          return name.replace(/-/g, ' ');
        }

        function englishGenus(genera) {
          if (!Array.isArray(genera)) return '';
          const en = genera.find(g => (g.language?.name || g.language) === 'en');
          return en?.genus || '';
        }

        function captureRateApprox(rate) {
          const r = Number(rate);
          if (!isFinite(r) || r < 0) return 0;
          // Rough approximation: rate/255 chance, show one decimal
          return Math.round((r / 255) * 1000) / 10;
        }

        async function loadEncounters(identifier, pokeData) {
          encountersLoading.value = true;
          encountersError.value = "";
          encounters.value = null;
          try {
            // Try backend summary first
            try {
              const r = await fetch(`/api/pokemon/${encodeURIComponent(identifier)}/encounters`);
              if (r.ok) {
                const s = await r.json();
                if (s && s.locations) {
                  encounters.value = s;
                  return;
                }
              }
            } catch (_) { /* ignore */ }

            // Fallback: fetch from PokeAPI encounters URL and summarize here
            const url = pokeData?.location_area_encounters;
            if (!url) return;
            const r2 = await fetch(url);
            if (!r2.ok) throw new Error(`Failed to load encounters (${r2.status})`);
            const payload = await r2.json();
            if (!Array.isArray(payload)) {
              encounters.value = { error: 'Unexpected response', full_url: url };
              return;
            }
            const summary = { pokemon: identifier, total_locations: payload.length, locations: [] };
            for (const enc of payload) {
              const location = enc?.location_area?.name || 'unknown';
              const versions = [];
              for (const vd of (enc?.version_details || [])) {
                const version = vd?.version?.name || 'unknown';
                const max_chance = vd?.max_chance || 0;
                const methods = Array.from(new Set((vd?.encounter_details || []).map(ed => ed?.method?.name || 'unknown')));
                versions.push({ version, max_chance, methods });
              }
              summary.locations.push({ location, versions });
            }
            summary.full_url = url;
            encounters.value = summary;
          } catch (e) {
            encountersError.value = e?.message || String(e);
          } finally {
            encountersLoading.value = false;
          }
        }

        onMounted(loadGenerations);

        // Also watch pokemon and re-render chart when it changes (covers re-loads)
        watch(pokemon, () => {
          if (pokemon.value) renderStatsChart();
        });

        return { generations, selectedGen, species, selectedPokemon, speciesOpen, loading, error, pokemon, search, loadSpecies, toggleSpeciesList, chooseSpecies, primarySprite, types, abilities, stats, cries, spriteVariants, typeStyle, statsCanvas, speciesDetails, evoLoading, evoError, evoPaths, encountersLoading, encountersError, encounters, prettify, englishGenus, captureRateApprox };
      }
    }).mount('#app');
  </script>
</body>
</html>